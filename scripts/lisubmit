#!/usr/bin/env bash
###########################################################################
# DO NOT EDIT! This script was auto-generated. To update this script, edit
# the file script-gen/lisubmit, and run './generate-scripts.sh'
###########################################################################
#8e39c52bfb32dd9faeee76400d393f81

COLOR_FG_BOLD_BLUE='\033[1;34m'
COLOR_FG_GREEN='\033[0;32m'
COLOR_FG_RED='\033[0;31m'
COLOR_RESET='\033[0m'
DOTFILES_DIR='/Users/mistewar/dotfiles'
based_on_master_or_origin ()
{
    local tracking_branch="$(git rev-parse --abbrev-ref --symbolic-full-name $1@{u} 2>/dev/null)";
    if [ "$tracking_branch" == "origin/master" ]; then
        echo "origin/master";
    else
        echo "master";
    fi
}
commit_diff_on_branch ()
{
    local git_rev_list_origin="$(git rev-list --count --left-right "$1"..."$2" 2>/dev/null)";
    if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
        local git_origin_arr=($git_rev_list_origin);
        echo "${git_origin_arr[0]}";
    else
        echo "0";
    fi
}
current_git_branch ()
{
    echo "$(git rev-parse --abbrev-ref HEAD)"
}
do_cmd ()
{
    local cmd_args="";
    for arg in "$@";
    do
        case "$arg" in
            *\ *)
                cmd_args="$cmd_args \"$arg\""
            ;;
            *)
                cmd_args="$cmd_args $arg"
            ;;
        esac;
    done;
    echo -e "${COLOR_FG_GREEN}($cmd_args )${COLOR_RESET}" 1>&2;
    command "$@"
}
do_git ()
{
    do_cmd git "$@"
}
echo_ack ()
{
    echo -e "${COLOR_FG_GREEN}$@${COLOR_RESET}" 1>&2
}
echo_err ()
{
    echo -e "${COLOR_FG_RED}$@${COLOR_RESET}" 1>&2
}
echo_fail_banner ()
{
    echo_err "***************";
    echo_err "*  Failed :(  *";
    echo_err "***************"
}
echo_info ()
{
    echo -e "${COLOR_FG_BOLD_BLUE}$@${COLOR_RESET}" 1>&2
}
echo_success_banner ()
{
    echo_ack "****************";
    echo_ack "*  Success :)  *";
    echo_ack "****************"
}
get_li_rb_api_def ()
{
    local api_def="";
    local cache_file="$DOTFILES_DIR/cache/li-rb-api-def.cache";
    local cache_file_expired="$(find $cache_file -mtime +1)";
    if [ -n "$cache_file_expired" ]; then
        echo_info "RB API definitions not cached, requesting...";
        api_def="$(curl -X GET -H 'Accept: application/json' 'https://rb.corp.linkedin.com/api/' 2>/dev/null)";
        exit_code="$?";
        if [ "$exit_code" -ne 0 ]; then
            echo_err "Failed to get RB API definitions. Exit code was: $exit_code";
        else
            echo "$api_def" > "$cache_file";
        fi;
    else
        api_def=$(<"$cache_file");
    fi;
    echo "$api_def"
}
get_li_rb_title ()
{
    if [ -n "$1" ]; then
        api_uri_template=$(get_li_rb_uri_template "review_request");
        request_url=${api_uri_template/\{review_request_id\}/$1};
        if [ -n "$request_url" ]; then
            summary=$(curl -X GET -H 'Accept: application/json' "$request_url" 2>/dev/null | jq --raw-output '.review_request.summary');
            echo "$summary";
        fi;
    fi
}
get_li_rb_uri_template ()
{
    template="$(get_li_rb_api_def | jq --raw-output ".uri_templates.$1")";
    echo "$template"
}
git_review_board_id ()
{
    echo "$(git config --get branch.$1.reviewid)"
}
git_undo_merge ()
{
    do_git reset --merge ORIG_HEAD && do_git checkout "$1"
}
gmt ()
{
    do_git mergetool --tool=opendiff
}
gpr ()
{
    local branch_name=$(current_git_branch);
    do_git fetch --all --prune;
    do_git rebase "origin/$branch_name"
}
in_git_repo ()
{
    git status > /dev/null && return 0 || echo_err "Not in git repo" && return 1
}
no_uncommitted_changes ()
{
    [ "$(git status --porcelain --untracked-files=no)" != "" ] && echo_err ">_<  You have uncommitted changes" && return -1 || return 0
}
not_on_git_branch ()
{
    [ "$(current_git_branch)" == "$1" ] && echo_err ">_<  Doesn't work on branch '$1'" && return -1 || return 0
}
requirement_check ()
{
    local cmd="$1";
    local how_to_install="$2";
    if [ ! $(command -v $cmd) ]; then
        echo_err "[ERROR] Command '$cmd' is required for this script, but not installed";
        echo_err "To install: $how_to_install";
        return 1;
    else
        return 0;
    fi
}
squash_branch ()
{
    local branch_name=$(current_git_branch);
    local based_on=$(based_on_master_or_origin $branch_name);
    local num_commits_on_branch="$(commit_diff_on_branch $branch_name $based_on)";
    echo_info "$num_commits_on_branch change(s) between '$branch_name' and '$based_on'";
    echo -n "Confirm squashing $num_commits_on_branch commits [Y/n]: ";
    read confirm;
    if [ -z "$confirm" ] || [ "$confirm" == "Y" ] || [ "$confirm" == "y" ]; then
        squash_commits "$num_commits_on_branch" "$1" "$2";
    else
        echo "Not squashing";
        return -1;
    fi
}
squash_commits ()
{
    if [ -n "$1" ] && [ "$1" -gt 0 ]; then
        if [ -n "$2" ]; then
            if [ -n "$3" ]; then
                do_git reset --soft HEAD~${1} && do_git commit -m "$2" -m "$3";
            else
                do_git reset --soft HEAD~${1} && do_git commit -m "$2";
            fi;
            if [ "$?" -ne 0 ]; then
                echo_err "Dang it! Squashing commits failed somehow";
                return 1;
            fi;
        else
            echo_err "Come on! You gotta have a commit message";
            return 1;
        fi;
    else
        echo_err "-_- No changes to squash";
        return 1;
    fi;
    return 0
}
show_help_msg() {
  echo "lisubmit - Squash commits, rebase, merge, and submit, for LI workflow"
  echo 'Usage: lisubmit [options] commit_msg [commit_msg_extra_line]'
  echo ''
  echo 'Options:'
  echo '  -h                      Show this help message'
  echo ''
  echo 'Arguments:'
  echo '  commit_msg              Message for the commit'
  echo '  commit_msg_extra_line   (optional) Optional extra line for more details and/or overrides'
}
while getopts ":h" opt
do
  case $opt in
    h)
      show_help_msg && exit 0
      ;;
    \?)
      echo_err "$0: invalid option '-$OPTARG'"
      exit 1
      ;;
    :)
      echo_err "$0: option '-$OPTARG' requires an argument"
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))
combined_return=0
requirement_check jq "search 'how to install jq'"
combined_return=$(( combined_return + $? ))
requirement_check find "search 'how to install find'"
combined_return=$(( combined_return + $? ))
requirement_check git "search 'how to install git'"
combined_return=$(( combined_return + $? ))
requirement_check curl "search 'how to install curl'"
combined_return=$(( combined_return + $? ))
if [ "$combined_return" != 0 ]; then exit $combined_return; fi
commit_msg="${1:?Missing argument 'commit_msg'}"
commit_msg_extra_line="${2}"
in_mint_submit_repo() {
  if [ -f "$PWD/product-spec.json" ]; then
    submit_def="$(cat $PWD/product-spec.json | jq '.build.commands.submit')"
    [ "$submit_def" != 'null' ]
    return
  else
    return
  fi
}
branch_name="$(current_git_branch)"
review_id="$(git_review_board_id $branch_name)"
exit_code="$?"
if [ "$exit_code" -ne 0 ]
then
  echo -e "${COLOR_FG_RED}Dang it! Getting the review board ID failed${COLOR_RESET}" >&2
  exit "$exit_code"
fi
echo_info "Submitting RB $review_id"
review_title="$(get_li_rb_title $review_id)"
if [ -z "$commit_msg" ]
then
  commit_msg="$review_title"
fi
echo -n "Commit message [$commit_msg]: "
read commit_msg
if [ -z "$commit_msg" ]; then commit_msg="$commit_msg"; fi
echo "Commit message 2nd line, for overrides"
echo "These should only be used by oncall, or for immediate response situations:"
echo "  ACLOVERRIDE           - cannot get an ACL owner to ship within your SLA"
echo "  PCVALIDATIONOVERRIDE  - unblock trunk with a non-functional change (fixing ACL, extending whitelist)"
echo "  LIXOVERDUEOVERRIDE    - if precommit is being blocked by an overdue lix"
echo "  DISABLEDTESTOVERRIDE  - bypass enforcement of disabled tests per pillar"
echo "  I18NOVERRIDE          - bypass i18n validation in precommit"
echo "  PCLOVERRIDE           - fix compatibility test that is failing in PCL"
echo "  EOLVALIDATIONOVERRIDE - commit is blocked by out of date dependency"
echo "  TRUNKBLOCKERFIX       - override trunk lock"
echo "  CHERRYPICKOVERRIDE    - commit a change to hotfix branch but not master"
echo -n "[$commit_msg_extra_line]: "
read commit_msg_extra
if [ -n "$commit_msg_extra" ]; then commit_msg_extra_line="$commit_msg_extra"; fi
if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes
then
  squash_branch "$commit_msg" "$commit_msg_extra_line"
  exit_code="$?"
  if [ "$exit_code" -ne 0 ]
  then
    echo -e "${COLOR_FG_RED}Dang it! squashing failed (TODO: auto recovery here?)${COLOR_RESET}" >&2
    exit "$exit_code"
  fi
  do_git pull --rebase origin master && do_git checkout master && do_git pull --rebase
  while [ "$?" -ne 0 ]; do
    read -p "Press any key to continue... " -n1 -s # DEBUG
    gmt && do_git rebase --continue
  done
  do_git merge "$branch_name"
  if [ "$?" -ne 0 ]; then
    echo_err "Dang it! merge failed - good luck"
    gmt
    read -p "Press any key to continue... " -n1 -s # DEBUG
  fi
  do_git review dcommit -r "$review_id"
  if [ "$?" -ne 0 ]; then
    echo_err "Dang it! 'git review dcommit' failed, undoing the merge"
    git_undo_merge "$branch_name"
    exit 1
  fi
  if in_mint_submit_repo; then
    echo_info "supports mint submit? YES"
    do_cmd mint submit
    if [ "$?" -ne 0 ];then
      echo_fail_banner
    else
      echo_success_banner
    fi
    echo_info "Undoing the merge so I can keep working..."
    git_undo_merge "$branch_name"
  else
    echo_info "supports mint submit? NO"
    do_git submit
    if [ "$?" -ne 0 ]; then
      echo_fail_banner
      echo_info "Undoing the merge..."
      git_undo_merge "$branch_name"
      exit 1
    fi
    echo_success_banner
    echo_info "Pulling changes into master..."
    gpr
  fi
fi
