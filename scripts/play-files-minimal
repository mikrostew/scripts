#!/usr/bin/env bash
# Play the input files randomly, displaying the artist and song for the stream in a very small terminal window

# To hide the title bar and make this look nice and minimal, set these in iTerm2:
# iTerm2 > Preferences > Appearance > Tabs > Show tab bar even when there is only one tab  --> unselected
# iTerm2 > Preferences > Appearance > General > Theme  --> Minimal
# (will have to restart it for this to take effect)

# NOTE: You need to install `shuf`, which you can do with `brew install coreutils`

# fail if any command fails
set -e

# colors and things
COLOR_RESET='\033[0m'
COLOR_BG_WHITE='\033[0;107m'
COLOR_FG_LIGHT_GRAY='\033[0;37m'
COLOR_FG_BOLD_LIGHT_GRAY='\033[1;37m'
MUSIC_NOTE="${COLOR_BG_WHITE}ðŸŽµ${COLOR_RESET}"

# set this up for if/when I Ctrl-C out of this, and on normal exit
reset_things() {
  # make sure the cursor is visible
  tput cnorm
  # reset the font size
  osascript -e 'tell application "System Events" to keystroke "0" using command down'
}
trap reset_things EXIT

# check that something was input (could also use $#)
if [ "$#" -eq 0 ]
then
  echo "no input files provided"
  exit 1
fi

# randomize the order of the input files
# shuf puts each one on a separate line, so use readarray to put that in the array correctly
readarray -t song_list <<< "$(shuf -e "$@" )"

# setup the terminal

# resize
# see http://invisible-island.net/xterm/ctlseqs/ctlseqs.html, search "window manipulation"
printf '\033[8;2;80t' # 80W x 2H chars

# reposition
# get the current resolution:
resolution="$(system_profiler -json SPDisplaysDataType | jq -r '.SPDisplaysDataType[] | select(.spdisplays_ndrvs != null) | .spdisplays_ndrvs[] | select(.spdisplays_main == "spdisplays_yes") | ._spdisplays_resolution')"
# for example, that returns: 1680 x 1050
if [[ "$resolution" =~ ([0-9]+)\ x\ ([0-9]+) ]]
then
  display_width="${BASH_REMATCH[1]}"
  display_height="${BASH_REMATCH[2]}"
  echo "resolution is $display_width x $display_height"
  # reposition this 80 pixels up from the bottom, and 10 pixels from the left, which looks about right
  xpos="10"
  ypos="$(( $display_height - 80 ))"
  echo "repositioning to $xpos, $ypos"
  printf '\033[3;%s;%st' "$xpos" "$ypos"
else
  echo "Error: Unable to parse resolution from '$resolution'"
  echo "(not going to reposition)"
fi

# scale up the text to be legible
# this simulates hitting Cmd-0, then Cmd-<+> 3 times
osascript <<EOF
tell application "System Events" to keystroke "0" using command down
tell application "System Events" to keystroke "+" using command down
tell application "System Events" to keystroke "+" using command down
tell application "System Events" to keystroke "+" using command down
EOF

# make the cursor invisible
# (from https://www.unix.com/shell-programming-and-scripting/176837-bash-hide-terminal-cursor.html)
tput civis

# play the songs

for song in "${song_list[@]}"
do
  # first get the song info
  # each one of these is on a separate line, so read it into an array line by line
  readarray -t song_info <<< "$(ffprobe -loglevel error -show_entries format_tags=title,artist,url -of default=noprint_wrappers=1:nokey=1 "$song")"
  # then pull out the info
  title="${song_info[0]}"
  artist="${song_info[1]}"
  url="${song_info[2]}"

  # blank line so this will scroll down to only show the next 2 lines
  echo ""
  # show artist and title
  echo -e "$MUSIC_NOTE${COLOR_FG_LIGHT_GRAY}  Now Playing:${COLOR_FG_BOLD_LIGHT_GRAY} $artist - $title  $MUSIC_NOTE"
  # show a URL to the artist's page below the song that's playing
  # (spaced nicely so it lines up)
  echo -e -n "${COLOR_FG_LIGHT_GRAY}    $url${COLOR_RESET}"

  # play the song, suppressing the output
  # NOTE: this does not respond to commands like volume up/down - I have to show the display for that
  ffplay -nodisp -autoexit -volume 100 "$song" >/dev/null 2>&1 &
  # background that and wait, so that Ctrl-C will stop this script and not go to the next song
  wait "$!"
done &

# while that plays, discard all input, so this will not print things to the screen and mess up the display
while true
do
  # read input but don't echo it or store it anywhere
  read -rs
done
